/**
    Project: libtpc
    File name: reader.h

    @author valerio
    @version 1.0 7/18/17.
*/

#ifndef LIBTPC_LIBRARY_H
#define LIBTPC_LIBRARY_H

#include <string>
#include <vector>
#include <lucene++/LuceneHeaders.h>

namespace tpc::reader {

    static const std::string document_indexname = "fulltext";
    static const std::string sentence_indexname = "sentence";
    static const std::string document_indexname_cs = "fulltext_cs";
    static const std::string sentence_indexname_cs = "sentence_cs";

    static const int maxHits = 1000000;
    static const int field_cache_min_hits = 100000;

    /*!
     * @enum ResultType
     * @brief the type of supported searches and the respective results
     */
    enum class QueryType { document = 1, sentence = 2 };

    /*!
     * @struct Sentence
     * @brief data structure that contains information related to a sentence as the result of a search
     *
     * @var <b>identifier</b> the identifier of the sentence, corresponding to the sentence_id field of the document
     * stored in the Lucene index
     * @var <b>score</b> the score of the sentence returned by the search
     */
    struct Sentence {
        int identifier;
        double score;
    };

    /*!
     * @struct Document
     * @brief data structure that contains information related to a document as the result of a search
     *
     * @var <b>identifier</b> the identifier of the document, corresponding to identifier field of the document
     * stored in the Lucene index
     * @var <b>score</b> the score of the document returned by the search. For sentence queries, the score is the sum
     * of the scores of the sentences in the document that match the search normalized between 0 and 1
     * @var <b>matching_sentences</b> the list of ids of the sentences contained in the document that match the
     * search. This value is null if \b query_type is equal to  \e QueryType::document
     */
    struct Document {
        std::string identifier;
        double score;
        std::string year;
        std::vector<Sentence> matching_sentences;
    };

    /*!
     * @struct SearchResult
     * @brief results generated by a search
     *
     * @var <b>query_type</b> the type of query that generated the result
     * @var <b>hit_socuments</b> the documents that match the search query
     */
    struct SearchResult {
        QueryType query_type;
        std::vector<Document> hit_documents;
    };

    class index_exception: public std::exception {
        const char* what() const throw() override {
            return "index not found";
        }
    };

    class SearchIndex {
    public:
        static SearchResult get_search_hits(const std::string &index_root_dir, QueryType search_type,
                                            const std::string &query, const std::vector<std::string> &literatures,
                                            bool case_sensitive = false, bool sort_by_year = false);
    private:
        static Lucene::Collection<Lucene::IndexReaderPtr> get_subreaders(const std::vector<std::string>& literatures,
                                                                         const std::string& index_root_dir,
                                                                         const std::string& index_type);
        static SearchResult get_results_from_document_hit_collection(
                const Lucene::Collection<Lucene::ScoreDocPtr>& matches_collection,
                const Lucene::Collection<Lucene::IndexReaderPtr>& subreaders,
                Lucene::SearcherPtr searcher, bool sort_by_year = false);

        static SearchResult get_results_from_sentence_hit_collection(
                const Lucene::Collection<Lucene::ScoreDocPtr>& matches_collection,
                const Lucene::Collection<Lucene::IndexReaderPtr>& subreaders,
                Lucene::SearcherPtr searcher, bool sort_by_year = false);

        // comparators for reverse sorting of documents and sentence objects
        static bool document_score_gt(const Document& a, const Document& b) { return a.score > b.score; }
        static bool document_year_score_gt(const Document& a, const Document& b) {
            if (a.year != b.year) return a.year > b.year; return a.score > b.score; }
        static bool sentence_greater_than(const Sentence& a, const Sentence& b) { return a.score > b.score; }
    };
}

#endif